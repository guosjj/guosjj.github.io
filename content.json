{"pages":[{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://cdn.jsdelivr.net/gh/guosjj/blog_image/img/2022/1.png 网站名称：dio 网站地址：https://guosjj.github.io 网站简介：后端开发，技术分享 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"","text":"个人简介 分享很喜欢的老罗的一段话： “每一个生命来到世间都注定改变世界，别无选择。要么变得好一点，要么变得坏一点。你如果走进社会为了生存为了什么不要脸的理由，变成了一个恶心的成年人社会中的一员，那你就把这个世界变得恶心了一点点。如果你一生刚正不阿，如果你一生耿直，没有做任何恶心的事情，没做对别人有害的事情，一辈子拼了老命勉强把自己身边的几个人照顾好了，没有成名没有发财，没有成就伟大的事业，然后耿着脖子一生正直，到了七八十岁耿着脖子去世了。你这一生是不是没有改变世界？你还是改变世界了，你把这个世界变得美好了一点点。因为世界上又多了一个好人。“ 善恶终有报,天道好轮回。不信抬头看,苍天饶过谁。无论何时何地，我们都要保持一颗积极乐观、善良感恩的心。但行好事莫问前程，永远年轻，永远热内盈眶，永远保持正能量。💪💪💪💪💪💪冲鸭！！！！ -&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;个人信息：软件工程专业码畜一枚坚信代码改变世界 博客信息 网站采用的Icarus主题 追求尽可能的简洁，清晰，易用。 在Icarus主题之上进行了部分修改。 更新日志：–2022.06.11：暂无 本站推荐索引 博客主题相关 百度 技术知识点 Java并发知识点 其他 网易云音乐歌单分享 计划 暂无 时间轴记录","link":"/about/index.html"},{"title":"音乐歌单收藏","text":"温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"},{"title":"","text":"🎈🎈微笑墙🎈🎈暂无","link":"/album/index.html"},{"title":"","text":"碎碎念 tips：github登录后按时间正序查看、可点赞加❤️、本插件地址..「+99次查看」 碎碎念加载中，请稍等... $.getScript(\"/js/gitalk_self.min.js\", function () { var gitalk = new Gitalk({ clientID: '5cf593a6a13262f47886', clientSecret: 'bea29594721773a8ea004989f322a544c5deb24c', id: '666666', repo: 'issue_database', owner: 'guosjj', admin: \"guosjj\", createIssueManually: true, distractionFreeMode: false }); gitalk.render('comment-container1'); });","link":"/self-talking/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 ->点击以下条目开始播放视频,向下滑动查看更多","link":"/media/index.html"}],"posts":[{"title":"你好世界！","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post1&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/%E4%BD%A0%E5%A5%BD%E4%B8%96%E7%95%8C.html"},{"title":"java类间六大关系","text":"在六种关系中，从弱到强排列分别是:依赖、关联、聚合、组合、继承(泛化)、实现。 六大关系（依赖，关联，聚合，组合，泛化，实现）一句话总结：依赖是顶级接口。继承，实现和关联实现了依赖。聚合和组合又继承了关联。 依赖关系：只要是在类中用到了对方，那么它们之间就存在依赖关系。 关联关系：关联关系实际上就是类与类之间的联系，他是依赖关系的特例 聚合关系:整体和部分的关系，整体和部分可以分开（如人和人的身份证），聚合关系时关联关系的特例。 一个类computer（电脑） 里有两个成员变量mouse（鼠标），monitor（显示器），电脑没有鼠标显示器，它还是个电脑，这是聚合关系。 1234public class Computer{ private Mouse mouse; private Monitor monitor; } 聚合关系如图所示：Mouse和Monitor被聚合到了Computer类中，使用空心菱形表示 但是如果对Monitor设置了级联删除，即删除Computer时连同Monitor一起删除，那Monitor和Computer则时组合关系了。 组合关系:也是整体和部分的关系，但是整体和部分不可以分开（如人和人的脑袋） 而组合的耦合度比聚合更高，在computer类实例化时，mouse和monitor也实例化了，此时computer和mouse和monitor同生共死。 1234public class Computer{ private Mouse mouse = new Mouse(); private Monitor monitor = new Monitor(); } 组合关系如图所示：Mouse和Monitor被组合到了Computer类中，使用实心菱形表示 泛化关系：泛化关系就是继承关系 A类继承B类。 泛化如图：PersonServiceBean类继承(泛化)了DaoSupport类 实现关系：概念:实现是类元之间的语义关系，其中一个类元指定了由另一个类元保证执行的契约。 具体体现: java通过接口来实现多继承，一个接口或者抽象类，定义好一组操作，由具体的实现类去完成接口的具体操作。 图片来源于尚硅谷，地址：https://www.bilibili.com/video/BV1G4411c7N4?p=27&amp;vd_source=d725aea58cd97ddffa992541a2d50d9d","link":"/java/java%E7%B1%BB%E9%97%B46%E5%A4%A7%E5%85%B3%E7%B3%BB.html"},{"title":"redis事务","text":"redis事务和锁机制Redis 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 Redis 事务的主要作用就是串联多个命令防止别的命令插队。 redis事务命令 开启事务：multi 执行事务：exec 取消事务：discard 开启、执行、取消事务 12345678910111213141516127.0.0.1:6379&gt; multi #开启事务OK127.0.0.1:6379(TX)&gt; incrby k1 20 #命令入队QUEUED127.0.0.1:6379(TX)&gt; exec #执行命令1) (integer) 30127.0.0.1:6379&gt; multiOK127.0.0.1:6379(TX)&gt; set k2 v2QUEUED127.0.0.1:6379(TX)&gt; set k3 v3QUEUED127.0.0.1:6379(TX)&gt; discard #取消事务OK127.0.0.1:6379&gt; 编译型异常（代码有问题！ 命令有错！） ，事务中所有的命令都不会被执行！ 123456789101112131415161718127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set k1 v1QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; set k3 v3QUEUED127.0.0.1:6379&gt; getset k3 # 错误的命令(error) ERR wrong number of arguments for 'getset' command127.0.0.1:6379&gt; set k4 v4QUEUED127.0.0.1:6379&gt; set k5 v5QUEUED127.0.0.1:6379&gt; exec # 执行事务报错！(error) EXECABORT Transaction discarded because of previous errors.127.0.0.1:6379&gt; get k5 # 所有的命令都不会被执行！(nil) 运行时异常（1/0）， 如果事务队列中存在语法性，那么执行命令的时候，其他命令是可以正常执行 的，错误命令抛出异常！ 123456789101112131415161718192021127.0.0.1:6379&gt; set k1 &quot;v1&quot;OK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; incr k1 # 会执行的时候失败！QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; set k3 v3QUEUED127.0.0.1:6379&gt; get k3QUEUED127.0.0.1:6379&gt; exec1) (error) ERR value is not an integer or out of range # 虽然第一条命令报错了，但是依旧正常执行成功了！2) OK3) OK4) &quot;v3&quot;127.0.0.1:6379&gt; get k2&quot;v2&quot;127.0.0.1:6379&gt; get k3&quot;v3&quot; 悲观锁和乐观锁​ 悲观锁： 很悲观，认为什么时候都会出问题，无论做什么都会加锁！ 乐观锁： 很乐观，认为什么时候都不会出问题，所以不会上锁！ 更新数据的时候去判断一下，在此期间是否有人修改过这个数据。 获取version 更新的时候比较 version 监控(watch) 1234567891011121314151617127.0.0.1:6379&gt; watch k1OK127.0.0.1:6379&gt; multiOK127.0.0.1:6379(TX)&gt; incrby k1 20QUEUED127.0.0.1:6379(TX)&gt; exec #第一位用户先对k1进行操作1) (integer) 30127.0.0.1:6379&gt; watch k1OK127.0.0.1:6379&gt; multiOK127.0.0.1:6379(TX)&gt; incrby k1 10QUEUED127.0.0.1:6379(TX)&gt; exec #第二位用户后对k1进行操作1) (error) ERR value is not an integer or out of range #因为k1的值发生了改变，执行事务失败 可以使用unwatch取消监控 redis事务3特性 单独的隔离操作 事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 没有隔离级别的概念 队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行。 不保证原子性 事务中如果有一条命令执行失败，其后的命令任然被执行，没有回滚。","link":"/%E7%AC%94%E8%AE%B0/redis/redis%E4%BA%8B%E5%8A%A1.html"},{"title":"Linux教程笔记","text":"韩顺平老师的Linux教程笔记 整篇笔记的使用环境是CentOS 6.x的版本 自用，侵删 1、环境准备1.1、共享文件夹 - vmtools 可以通过vmtools这个工具实现： 可以直接粘贴命令在Windows和Linux之间 可以设置Windows和Linux的共享文件夹 安装 点击 VMwareStation 上的虚拟机 -&gt; install vmware tools centos 会有一个安装包，将其中的压缩文件解压就会得到一个安装文件 解压命令：tar -zxvf xxx.tar.gz 注意：如果要将压缩包复制到别的目录下，要注意权限问题，一般用root账户登录就能避免 进入解压的目录，安装 ./vmware-install.pl 全部使用默认设置即可 需要重启系统 设置共享文件夹 在实际的开发中，文件的上传和下载是用远程方式操作的 Windows端：虚拟机 -&gt; 设置 -&gt; 选项 -&gt; 共享文件夹 -&gt; 总是启用 -&gt; 添加Windows的文件夹路径 Linux端：根目录下的mnt -&gt; hgfs -&gt; 这里就是共享的文件夹 2、Linux目录结构2.1、基本介绍 Linux中，/即代表根目录，不同于Windows的C、D、E盘结构，Linux只有一个根目录，然后在此目录下创建其他目录，是树结构 Linux的文件系统采用级层式的树状目录结构，最上层目录就是根目录，有且只有一个 ==Linux世界里，一切皆为文件==，即使是硬件，也会被映射成相应的文件 ==Linux开机流程：开机 =&gt; BIOS =&gt; /boot =&gt; init进程 =&gt; 运行级别 =&gt; 运行级别对应的服务== 2.2、根目录1234567891011121314151617181920212223242526272829303132333435363738/bin 这个目录存放着最经常使用的命令，主要有cat、chmod、chown、date、mv、mkdir、cp、bash等/sbin 存放着系统管理员使用的系统管理程序，包括开机过程所需要的开机、修复、还原系统所需要的命令/home 存放普通用户的主目录，每个用户都有一个自己的目录，一般目录名以用户账号命名，主文件夹有两种代号：～代表当前这个用户的主文件夹/root 超级权限者的用户主目录，系统管理员的主文件夹/lib 放置的是系统开机所需要最基本的动态链接共享库，类似于Windows的DLL文件，包括开机时会用到的数据库，以及在/bin和/sbin下命令会调用的函数库/lost+found 一般情况下是空的，系统非法关机后，系统就会存放一些文件/etc 所有系统管理员所需要的配置文件和子目录，例如人员的帐号密码文件，各种服务的起始文件等。一般来说，这个目录下面的各文件属性时可以让一般的用户查阅的，但是只有root用户有权先修改。FHS建议不要放置可执行的文件在这个目录下/usr 这里面放置的数据属于可分享的与不可变动的（shareable，static），其实usr是UNIX SOFTWARE RESOURCE的缩写，而非user的缩写，也就是unix操作系统软件放置的位置而非用户的数据/boot 这个目录主要放置开机能够使用到的文件，包括linux内核文件和开机菜单与开机所以需要的配置文件====================================================================================================一下三个目录跟Linux内核有关，一般不要动/proc 这个目录本身是一个虚拟文件系统，它放置的数据都是在内存当中，不占用硬盘的容量/src src可以视作service的缩写，是一些网络服务启动后，这些服务需要取用的数据目录，常见的服务例如www,ftp等/sys 这个目录其实跟/proc非常的相似，也是一个虚拟的文件系统主要也是记录与内核相关的信息，不占用硬盘容量====================================================================================================/tmp 这是让一般的用户或者是正在执行的程序暂时放置文件的地方/dev 在linux中任何的设备和接口设备都是以文件的形式存在于这个目录当中。你只要到通过访问这个目录下的某个文件就相当于访问某个设备，类似于Windows的设备管理器/media 放置的就是可以删除的设备。包括软盘，光盘，dvd等都临时挂放在此。/mnt 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在该目录下，然后进入该目录就能看见了，例如vmtools的共享文件夹/opt 这个是给第三方软件放置的目录。不过，在以前的linux下我们喜欢放置在/usr/local下面，一般是通过编译源码方式安装的程序。/var 这个目录下面主要放置常态性变动的文件，包括cache,logfile以及某些软夹运营所产生的文件。例如MYSQL数据库文件等/selinux SeLinux是一种安全子系统他能控制程序只能访问特定文件 2.3、小结 Linux有且只有一个根目录 Linux的各个目录存放的内容是预先规划好的，不要乱放文件 Linux是以文件的形式来管理设备，因此Linux中一切皆为文件 Linux的各个文件目录下存放什么内容必须有一个认识，最好能指哪个说哪个 学习后脑子里应该有一颗目录树 3、远程登录到Linux服务器3.1、为什么要远程登陆呢？ 如果是实际的开发，Linux服务器一般是在第三方服务商的机房里，那么要控制Linux服务器，就要同构远程登陆的方式来操作 还有文件的上传和下载，也要通过远程登录的方式 可以用termius / XShell 远程登陆 / Xftp 远程文件上传下载 安装之前要先开启Linux的远程监听服务，然后开启服务来供远程终端连接，一般云服务器会用一个密钥来连接，该服务监听22号端口 setup -&gt; 系统服务 -&gt; sshd 查看是否开启远程监听服务（SSHD），* 代表已经开启；service sshd status 也可以检查 3.2、连接Linux 通过XShell连接到Linux服务器 1ifconfig 查看IP地址 默认nat模式下，linux的IP与虚拟的网卡IP不一样，要设置端口转发，才能确保正常连接！ Linux虚拟机的三种网络连接形式 桥接模式：与主机在同一网段，Linux可以和其他系统通信，但是如果Linux虚拟机数量多可能造成ip冲突 NAT模式：网络地址转换方式，即母机代理通讯，再创建子网供虚拟机使用，其中一个和Linux无法和本局域网中的其他真实主机进行通讯 仅主机模式：即单机模式，是一个独立的主机，不能访问外网 ==一般选择NAT模式== 3.3、远程下载和上传文件可以使用Xftp软件进行文件的传输，直接安装即可，然后输入Linux主机的IP地址，选择SFTP协议（22号端口），再输入账号密码即可 如果出现中文乱码问题，可以在主机的属性中的选项中选择使用UTF-8编码即可 直接拖拉文件即可 4、Vi和Vim编辑器4.1、基本介绍 所有Linux系统都会内建vi文本编辑器 Vim具有程序编辑的能力，可以当作是vi的增强版，可以主动的以字体颜色辨别语法的正确性，方便程序设计。代码补全、编译及错误跳转等方便编程的功能特别丰富，被广泛使用。 4.2、vi和vim的三种常见模式 正常模式 一般默认就是正常模式，在该模式下，我们可以使用快捷键。 以 vim 打开一个档案就直接进入一般模式了(这是默认的模式)。在这个模式中，你可以使用『上下左右』按键来移动光标，你可以使用『删除字符』或『删除整行』来处理档案内容，也可以使用『复制、粘贴』来处理你的文件数据。 插入模式（编辑模式） 在模式下，程序员可以输入内容。 按下 i, I, o, O, a, A, r, R 等任何一个字母之后才会进入编辑模式, 一般来说按i即可 命令行模式 在这个模式当中， 可以提供你相关指令，完成读取、存盘、替换、离开 vim 、显示行号等的动作则是在此模式中操作的 4.3、快速入门案例 写一个hello world的 java 代码文件 12345678910111213ll 查看目录下的文件vim Hello.java 用vim打开一个java文件输入 i 进入编辑模式输入代码:public class Hello{ public static void main(String args[]){ System.out.println(&quot;Hello World&quot;); }}输入完成后按ESC按键，从编辑模式切换到正常模式输入 :或者/ 后即可从正常模式切换到命令行模式输入 wq (w是写入的意思 q是退出的意思) 保存 q 是退出，如果有修改，就会提示加上 ! 强制执行，这样修改的内容就会消失 4.4、快捷键使用案例 要先从进入正常模式才可以使用快捷键 拷贝当前行 yy , 拷贝当前行向下的 5 行 5yy，并粘贴 p 删除当前行 dd , 删除当前行向下的 5 行 5dd 在文件中查找某个单词：命令行下 / 关键字 ， 回车 查找 , 输入 n 就是查找下一个 设置文件的行号，取消文件的行号：命令行下:set nu 和 :set nonu 编辑 /etc/profile 文件，使用快捷键到底文档的最末行G和最首行gg，注意这些都是在==正常模式==下执行的 在一个文件中输入 “hello” ,然后又撤销这个动作，在正常模式下输入 u 取消着色标记操作是 :noh 编辑 /etc/profile 文件，并将光标移动到 第 20 行 shift+g 第一步：显示行号 :set nu 输入20，直接按回车的话，是从当前位置前进20行 数字+Enter 可以到 光标当前位置+数字 的那一行 第二步：输入 20 这个数 第三步: 输入 shift+g 单行注释 # 后面写注释 多行注释：:&lt;&lt;! 中间的代码 ! 4.5、vim键盘图 5、开机、重启和用户登录注销5.1、关机和重启1234567shutdown shutdown -h now 立即关机 shutdown -h 1 表示一分钟过后就关机 shutdown -r now 立即重启halt 停机指令 直接使用即可 效果等同于关机reboot 就是重启系统sync 代表把内存的数据同步到磁盘上 不管是重启还是关机，都应该先执行以下 sync 指令，把内存的数据写入磁盘，防止数据丢失 5.2、用户登录和注销 登录时尽量少用 root 帐号登录，因为它是系统管理员，拥有最大的权限，避免操作失误。可以利用普通用户登录，登录后再用su - 用户名 命令来切换成系统管理员身份 在提示符下输入logout即可注销用户 logout 注销指令在图形运行级别无效即在虚拟机上操作时无效，在 运行级别 3 下有效，例如远程连接时使用 6、用户管理6.1、基本介绍 Linux 系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统 用户组：Linux下有很多地用户组，这是Linux对用户管理地一种管理，每一个用户至少属于一个组，例如 root 用户属于 root 组 家目录：/home/ 目录下有各个创建的用户对应的家目录，当用户登录时会自动地进入到自己地家目录 6.2、添加用户 基本语法：useradd [选项] 用户名 例如：添加用户小明 ==&gt; 添加完成后发生的变化： 有一个组被创建了(系统会默认创建一个同名用户组，当然也可以指定加入一个组)； /home/ 目录下有一个 xiaoming 的目录 123useradd xiaominguseradd -d /home/tiger xiaohong 给新创建的用户xiaohong指定家目录所在位置useradd -g groupname username 将新创建的用户添加到指定用户组 6.3、给用户指定/修改密码使用命令 passwd 用户名 12345678910passwd [-k] [-l] [-u [-f]] [-d] [-S] [username]-d 删除密码-f 强制执行-k 更新只能发送在过期之后-l 停止账号使用-S 显示密码信息-u 启用已被停止的账户-x 设置密码的有效期-g 修改群组密码-i 过期后停止用户账号 6.4、删除用户使用命令userdel username 12userdel xiaoming 删除用户 xiaoming 但是要保留家目录userdel -r xiaoming 删除用户 xiaoming 以及用户主目录 实际开发工作中，删除用户时一般不会将家目录删除，以免一些文件被误删 6.5、查询用户使用命令 id username 系统会显示：用户id号；所在组id号；组名 如果不存在该用户，会显示 无此用户 6.6、切换用户 在操作 Linux 中，如果当前用户的权限不够，可以通过 su - 指令，切换到高权限用户，比如 root 使用命令：切换：su - username 返回原来的用户：exit 高权限用户切换到低权限用户时不需要输入密码，反之需要 6.7、用户组 用户组：类似于角色，系统可以对有共性的多个用户进行统一的管理 增加组： groupadd groupname 123useradd -g groupname username 将新创建的用户添加到指定用户组usermod -g groupname username 修改某个用户的用户组usermod -d 目录名 用户名 改变该用户登录的初始目录 6.8、用户和组的相关文件6.8.1、/etc/passwd 文件 用户（user）的配置文件，记录用户的各种信息 每行的含义：用户名:密码:用户id:组id:注释性描述::家目录:登录 Shell 6.8.2、/etc/group 文件 组(group)的配置文件，记录 Linux 包含的组的信息 每行含义：组名:口令:组标识号:组内用户列表 6.8.3、/etc/shadow 文件 口令的配置文件（密码和登录信息，是加密的） 每行的含义： 登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志 7、实用指令7.1、指定运行级别 七大运行级别 1234567891011120 ：关机1 ：单用户【找回丢失密码】2：多用户状态没有网络服务3：多用户状态有网络服务4：系统未使用保留给用户 一般不使用5：图形界面6：系统重启常用运行级别是 3 和 5 ，要修改默认的运行级别可改文件系统的运行级别配置文件 /etc/inittab/etc/inittab 中的 id:5:initdefault: 这一行中的数字就代表着当前运行级别切换运行级别 init [0|1|2|3|5|6]也可以编辑文件中的那一行，然后reboot即可 systemctl get-default 查看当前运行级别 centos7中，这个文件在/lib/systemd/system 找回root用户的密码：可以进入单用户模式之后再使用passwd命令修改 7.2、帮助指令当我们对某个指令不熟悉的时候，我们可以使用Linux提供的帮助指令来了解这个指令的使用方法 通过man指令获得帮助信息：man [命令或配置文件] 通过help指令获得 shell 内置命令的帮助信息：help [命令] 当然，更推荐直接百度 按J或K滚动翻看 7.3、文件目录类指令 斜杠在前表示绝对路径，没有斜杠表示相对路径，斜杠在后表示某文件夹下的一个文件 pwd 命令( print woking dictionary )，显示当前工作目录的绝对路径 1使用方法：pwd ls 命令 ，显示当前目录的所有文件和目录，包括隐藏的 1234使用方法：ls [选项] [目录或是文件]-a 显示当前目录所有的文件和目录，包括隐藏的-l 以列表的方式显示信息-h 显示文件大小 cd 命令（change directory），切换到指定的目录 12345cd [绝对路径|相对路径]cd~ 或者 cd: 回到自己家目录cd .. 回到当前目录的上一级目录. 代表当前目录.. 代表上一级目录 mkdir 命令（make directory），用于创建目录 12mkdir [选项] 要创建的目录-p 创建多级目录，多级目录即创建一个目录后然后在这个目录下再创建一个目录，相当于创建两个目录 rmdir 命令（remove directory），用于删除==空目录== 123rmdir [选项] 要删除的空目录rm -rf 要删除的非空目录注意！rm -rf /* 是删除根目录下的所有内容，不要乱听别人说 touch 命令，用于创建空文件 12touch 文件名称也可以一次创建多个文件，空格分开即可 cp 命令（copy），拷贝文件到指定目录 12345cp [选项] 要拷贝的文件 要粘贴的目录-r 递归复制整个文件夹例1：cp a.txt /home/b/ 将a.txt文件拷贝到/home/b目录下例2：cp -r /home/a/ /home/b/ 将/home/a/目录下的所有文件递归拷贝到/home/b/下，当有重复文件的时候会提示是否覆盖例3：cp -r /home/a/ /home/b/ 这样就能强制覆盖系统不会提示，这样就不用一个一个文件的操作 rm 命令，删除文件或目录 123rm [选项] 要删除的文件或目录-r 递归删除整个文件夹-f 强制删除不提示 mv 命令，移动文件与目录，或重命名 1234mv 旧文件名 新文件名 重命名mv 源文件路径 目标文件路径 移动文件例1：mv a.txt b.txt例2：mv a.txt /home/ 如果移动到的文件夹内存在同名的文件会提示是否覆盖,也可以重命名 cat 命令，查看文件内容，以只读的方式打开 1234567cat [选项] 要查看的文件-n ：显示行号例1：cat -n /etc/profile 这样直接打开文件会一下走到最后一行然后退出到命令行 因此一般会加上 | more 来分页显示cat 只能浏览文件，而不能修改文件，为了浏览方便，一般会带上 管道命令 | morecat 文件名 | more [分页浏览]回车翻页 more 命令 more 指令是一个基于 VI 编辑器的文本过滤器，它以==全屏幕的方式按页显示文本文件的内容== more 指令中内置了若干快捷键，详见操作文档 12345678910more 要查看的文件常用快捷键：一行一行的看就按 Enter 键一页一页的看就按 空格 键Ctrl+B 回到上一页Ctrl+F 下一页q 立即离开more，不再显示文本内容= 输出当前行的行号:f 输出文件名和当前行的行号 less 命令 less 命令用来==分屏查看文件内容==，它的功能与 more 命令类似，但是更强大，支持各种显示终端 less 指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，==对于显示大型文件具有较高的效率== 123456789less 要查看的文件常用快捷键空格键 向下翻一页pagedown 向下翻一页pageup 向上翻一页/字符串 向下搜索字符串，n：向下查找 N：向上查找?字符串 向上搜索字符串，n：向上查找 N：向下查找q 离开less这个程序 &gt; 命令和&gt;&gt; 命令 &gt; 命令 输出重定向 : 会将原来的文件的内容覆盖 &gt;&gt; 命令 追加： 不会覆盖原来文件的内容，而是追加到文件的尾部 12345ls -l &gt;文件 将ls -l 显示的内容写入文件 a.txt 中（覆盖写）如果该文件不存在，就创建该文件ls -al &gt;&gt;文件 将ls -al 显示的内容追加到文件 a.txt 的末尾cat 文件 1 &gt; 文件 2 将文件1的内容覆盖到文件2echo &quot;str&quot;&gt;&gt;文件 将字符串内容追加到文件中echo &quot;str&quot;&gt;文件 将字符串的内容覆盖到文件中，原来的内容全都没了 echo 命令，输出内容到控制台 123echo [选项] [输出内容]例1 使用 echo 指令输出环境变量,输出当前的环境路径 ==&gt; echo $PATH例2 使用 echo 指令输出&quot;hello world&quot; ==&gt; echo &quot;hello world&quot; head 命令，用于显示文件的开头部分内容，默认情况下 head 指令显示文件的前 10 行内容 12head 文件 head -n 5 文件 查看文件头 5 行内容，5 可以是任意行数 tail 命令，用于输出文件中尾部的内容，默认情况下 tail 指令显示文件的后 10 行内容 1234tail 文件tail -n 5 文件 查看文件后 5 行内容，5 可以是任意行数tail -f 文件 实时追踪该文档的所有更新，实际开发工作中会经常使用，Ctrl+C退出追踪如果你是用的vim修改，因为vim实际上是删除本文件，生成了新的同名文件，所以无法进行监控 ln 命令，给原文件创建一个链接 软链接也叫符号链接，类似于 windows 里的快捷方式，主要存放了链接其他文件的路径 硬连接指通过索引节点来进行链接 关于硬连接和软连接的详细介绍 12345678910ln [参数] [原文件或目录] [目标文件或目录] -i 交互模式，文件存在则提示用户是否覆盖。-s 软链接(符号链接)。-d 允许超级用户制作目录的硬链接。-b 删除，覆盖以前建立的链接在默认不带参数情况下，ln命令创建的是硬链接例： ln -s /root linkToRoot 在当前目录下创建一个软链接，链接指向root目录当 cd linkToRoot 时，就会跳转到root目录，但是用pwd查看路径时，还是会显示原来目录的linkToRoot的路径 history 命令，查看已经执行过历史命令,也可以执行历史指令 12345history [数字]不加数字则显示所有的历史命令加数字则显示最近使用的n条命令!10 执行历史编号为10的命令history -c 清除历史记录 7.4、时间日期类指令 cal 命令，显示当前日历信息 123cal [选项]不加选项，显示本月日历cal 2020 显示2020年一整年的日历 date 命令，显示当前日期 / 设置当前日期 12345678910date 显示当前时间date +%Y 显示当前年份date +%m 显示当前月份date +%d 显示当前是哪一天date &quot;+%Y-%m-%d %H:%M:%S&quot; 显示年月日时分秒date -s 字符串时间 设置系统当前时间例：date -s &quot;2020-11-11 11:11:11&quot;设置回原来的时间ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 7.5、搜索查找类指令 find 命令，将从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端 12345find [搜索范围] [选项]-name&lt;查询方式&gt; 按照指定的文件名查找模式查找文件 例：find /home -name hello.txt -user&lt;用户名&gt; 查找属于指定用户名所有文件 例： find /root -user root-size&lt;文件大小&gt; 按照指定的文件大小查找文件 [+n大于 -n小于 n等于] 例：find /root -size +20M使用文件名查找时可以使用通配符，例：find /home -name *.txt locate 命令，快速定位文件路径 locate 指令利用==事先建立的系统中所有文件名称及路径的 locate 数据库==实现快速定位给定的文件 Locate 指令无需遍历整个文件系统，查询速度较快 为了保证查询结果的准确度，管理员必须定期更新 locate 时刻 由于 locate 指令基于数据库进行查询，所以==第一次运行前，必须使用 updatedb 指令创建 locate 数据库==。 12locate 搜索文件例：locate hello.txt grep 指令和 管道符号 | grep 过滤查找 ， 管道符|，表示将前一个命令的处理结果输出传递给后面的命令处理 12345grep [选项] 查找内容 源文件-n 显示匹配行及行号-i 忽略字母大小写例：cat hello.txt | grep -n yes 在 hello.txt 文件中，查找 &quot;yes&quot; 所在行，并且显示行号 7.6、压缩和解压缩类指令 gzip / gunzip 指令 gzip 用于==压缩文件==， gunzip 用于==解压缩== 压缩完成后，原来的文件就没了，取而代之的是对应的压缩文件，不会保留原来的文件 12gzip 文件 压缩文件，只能将文件压缩为 *.gz 文件gunzip 文件.gz 解压缩文件命令 zip / unzip 指令 zip 用于==压缩文件==， unzip 用于==解压缩==，这个在项目打包发布中很有用的 123456zip [选项] XXX.zip 将要压缩的内容 压缩文件和目录的命令unzip [选项] XXX.zip 解压缩文件zip ==&gt; -r：递归压缩，即压缩目录unzip ==&gt; -d&lt;目录&gt; ：指定解压后文件的存放目录例： zip -r home.zip /home/ ==&gt; 将 /home 下的 所有文件进行压缩成 home.zip例： unzip -d /home/ home.zip ==&gt; 将 mypackge.zip 解压到 /home 目录下 tar 指令，打包指令 最后打包后的文件是.tar.gz的文件 123456789101112131415tar [选项] XXX.tar.gz 打包的内容 打包目录，压缩后的文件格式.tar.gz-c 产生 .tar 打包文件-v 显示详细信息-f 指定压缩后的文件名-z 打包同时压缩-x 解包 .tar 文件-c create -t list -x extract -z gzip -j bzip2 -J xz -f filename例1 -&gt; tar -zcvf a.tar.gz a1.txt a2.txt ==&gt; 将 a1.txt 和 a2.txt 压缩成 a.tar.gz例2 -&gt; tar -zcvf myhome.tar.gz /home/ ==&gt; 将 /home/ 目录下所有文件打包压缩成 myhome.tar.gz例3 -&gt; tar -zxvf a.tar.gz ==&gt; 将 a.tar.gz 解压到当前目录例4 -&gt; tar -zxvf myhome.tar.gz -C /home/ ==&gt; 将 myhome.tar.gz 解压到 /home/ 目录下-C 应该是change，改变目录 指定解压缩的目标目录一定要事先存在 8、组管理8.1、基本介绍 在 linux 中的每个用户必须属于一个组，不能独立于组外 在 linux 中每个文件有所有者、所在组、其它组的概念 所有者：一般为文件的创建者，谁创建了该文件，就自然的成为该文件的所有者 所在组：文件也会归属于一个组，一般默认是所有者所在的组 其他组：除文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组. 8.2、文件 / 目录 所有者一般为文件的创建者，谁创建了该文件，就自然的成为该文件的所有者 查看文件所有者 1ls -ahl 即可查看文件的所有者和所在组 修改文件所有者 ==&gt; change owner 123chown [参数] 用户名 文件名chown newowner:newgroup file 改变用户的所有者和所有组-R 如果是目录 则使其下所有子文件或目录递归生效 递归的修改文件、目录的所有者 8.3、文件 / 目录 所在组当某个用户创建了一个文件后，默认这个文件的所在组就是该用户所在的组 查看文件所在组 1ls -ahl 修改文件所在组 ==&gt; change group 12chgrp [参数] 组名 文件名-R 如果是目录 则使其下所有子文件或目录递归生效 递归的修改文件、目录的所在组 9、权限管理9.1、基本介绍 ls -l 中显示的内容如下： ​ -rwxrw-r-- 1 root root 1213 Feb 2 09:39 abc 0-9 位说明 第 0 位确定文件类型(d 目录，- 普通文件， l 连接，c 字符设备，b 块文件例如硬盘) 第 1-3 位确定所有者（该文件的所有者）拥有该文件的权限。—User 第 4-6 位确定所属组（同用户组的）拥有该文件的权限，—Group 第 7-9 位确定其他组的用户拥有该文件的权限 —Other 这里的权限也可用数字表示为: r=4，w=2，x=1 因此 rwx=4+2+1=7 1 的意思是：如果是文件，表示硬连接的数；如果是目录，则表示该目录下有多少个子目录 所有者名称 所在组名称 文件大小，1213个字节，如果是目录会统一显示4096 文件最后的修改时间 文件名 9.2、rwx 权限详解 rwx 作用到文件 [ r ]代表可读(read)：可以读取，查看 [ w ]代表可写(write)：可以修改，==但是不代表可以删除该文件==，删除一个文件的前提条件是==对该文件所在的目录有写权限，才能删除该文件== [ x ]代表可执行(execute)：可以被执行 rwx 作用到目录 [ r ] 代表可读(read)：可以读取，ls 查看目录内容 [ w ] 代表可写(write)：可以修改，目录内创建+删除+重命名目录 [ x ] 代表可执行(execute)：可以进入该目录 9.3、修改权限 – chmod 通过 chmod 指令，可以修改文件或者目录的权限 第一种方式：通过+ 、-、= 变更权限 u：所有者 g：所在组 o：其他人 a：所有人(u、g、o 的总和) chmod u=rwx,g=rx,o=x 文件目录名 ==&gt; 给所有者读写操作的权限，给所在组读写权限，给其他人执行的权限 chmod o+w 文件目录名 ==&gt; 给其他人增加写权限 chmod a-x 文件目录名 ==&gt; 给所有人减少写权限 第二种方式：通过数字变更权限，其实就是二进制来表示，三个位分别用0和1表示权限的无和有 规则：r=4 w=2 x=1 ，rwx=4+2+1=7 ，rx=4+1=5 chmod u=rwx,g=rx,o=x 文件目录名 相当于 chmod 751 文件目录名 注意：对于目录，要拥有执行的权限才能进入目录 10、定时任务调度10.1、基本介绍 crond 定时任务调度 在我们写了一个脚本或代码，能够完成某个任务，但是需要定时完成，就能够使用一种机制，去定时的调度我们写好的脚本或代码 可以通过crontab进行定时任务设置 10.2、基本语法 任务调度：是指系统在某个时间执行的特定的命令或程序 任务调度分类： 系统工作：有些重要的工作必须周而复始地执行，如病毒扫描等 个别用户工作：个别用户可能希望执行某些程序，比如对mysql数据库的备份 1234crontab [选项]-e 编辑crontab定时任务-l 查询crontab任务-r 删除当前用户所有的crontab任务 对于一些简单的任务，可以不用写脚本，直接在crontab中加入任务即可 对于复杂的任务，就需要写脚本来完成（shell脚本） 10.3、快速入门任务要求： 设置任务调度文件：/etc/crontab 设置个人任务调度 执行 crontab –e 命令 接着输入任务到调度文件 如：*/1 * * * * ls –l /etc/ &gt; /tmp/to.txt 语句的意思说每小时的每分钟执行ls –l /etc/ &gt; /tmp/to.txt命令 具体步骤： crontab -e 进入编辑模式 输入代码：*/1 * * * * ls –l /etc/ &gt; /tmp/to.txt 按esc，再按i/a/o，就进入输入模式。按esc再按：进入末行，按esc，按R进入替换模式 当保存退出后就程序 在每一分钟都会自动的调用 ls -l /etc &gt;&gt; /tmp/to.txt 参数说明： 五个占位符 第一个 * =&gt; 一小时的第几分钟 0-59 第二个 * =&gt; 一天的第几小时 0-23 第三个* =&gt; 一个月当中的第几天 1-31 第四个 * =&gt; 一年当中的第几月 1-12 第五个 * =&gt; 一周当中的星期几 0-7（0和7都代表星期日） 特殊符号的说明 * 号代表任何时间 , 号代表不连续的时间 -号代表连续的时间范围 */n号代表没隔多久就执行一次 表达式例子： 123456745 22 * * * 命令 ==&gt; 在22点45分执行命令0 17 * * 1 命令 ==&gt; 在每周一的17点0分执行命令0 5 1,15 * * 命令 ==&gt; 在每月的1号和15号的凌晨5点0分执行命令40 4 * * 1-5 命令 ==&gt; 每周一到周五的凌晨4点40分执行命令*/10 4 * * * 命令 ==&gt; 每天的凌晨4点，每个10分钟执行一次命令0 0 1,15 * 1 命令 ==&gt; 每月的1号和15号，每周一的0点0分都会执行命令注意:星期几和几号最好不要同时出现，因为他们定义的都是天，很容易产生混乱 10.4、任务调度的几个应用实例10.4.1、第一个案例：每隔1 分钟，就将当前的日期信息，追加到 /tmp/mydate 文件 先编写一个文件 mytask1.sh 1date &gt;&gt; /tmp/mydate 给 mytask1.sh 一个可以执行权限 1chmod 744 mytask1.sh 执行命令 crontab -e 执行 */1 * * * * mytask1.sh 代码 10.4.2、第二个案例：每隔1 分钟， 将当前日期和日历都追加到 /home/mycal 文件中 先编写一个文件 /home/mytask2.sh 12date &gt;&gt; /tmp/mycal cal &gt;&gt; /tmp/mycal 给 mytask1.sh 一个可以执行权限 1chmod 744 /home/mytask2.sh crontab -e 进入定时任务调度 */1 * * * * /home/mytask2.sh 10.4.3、第三个案例：每天凌晨2:00 将mysql 数据库 testdb ，备份到文件中 先编写一个文件 /home/mytask3.sh 1/usr/local/mysql/bin/mysqldump -u root -proot testdb &gt; /tmp/mydb.bak 给 mytask3.sh 一个可以执行权限 1chmod 744 /home/mytask3.sh crontab -e 0 2 * * * /home/mytask3.sh 10.5、crond相关指令123conrtab –r ==&gt; 终止任务调度crontab –l ==&gt; 列出当前有那些任务调度service crond restart [重启任务调度] 11、Linux磁盘分区和挂载11.1、分区基础知识分区的两种方式： MBR分区（主引导记录） 最多支持四个主分区 系统只能安装在主分区 扩展分区要占一个主分区 MBR 最大只支持 2TB，但拥有最好的兼容性 GPT 分区（GUID Partition Table 全局唯一标识磁盘分区表） 支持无限多个主分区（但操作系统可能限制，比如 windows 下最多 128 个分区） 最大支持 18EB 的大容量（1EB=1024 PB，1PB=1024 TB ） windows7 64 位以后支持 gpt Windows下的分区 分为主分区和扩展分区（扩展分区下面可再分逻辑分区） 11.2、Linux分区 原理介绍： Linux 来说无论有几个分区，分给哪一目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构 , Linux 中每个分区都是用来组成整个文件系统的一部分。 Linux 采用了一种叫==“载入”==的处理方法，它的整个文件系统中包含了一整套的文件和目录， 且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得。 通俗来说，就是硬盘下的分区会映射成根目录下的某个目录 硬盘说明 Linux 硬盘分 IDE 硬盘和 SCSI 硬盘，目前基本上是 SCSI 硬盘 对于 IDE 硬盘，驱动器标识符为hdx~,其中hd表明分区所在设备的类型，这里是指 IDE 硬盘了。x为盘号（a 为基本盘，b 为基本从属盘，c 为辅助主盘，d 为辅助从属盘）,~代表分区，前四个分区用数字 1 到 4 表示，它们是主分区或扩展分区，从 5 开始就是逻辑分区。例如：hda3 表示为第一个 IDE 硬盘上的第三个主分区或扩展分区,hdb2 表示为第二个 IDE 硬盘上的第二个主分区或扩展分区 对于 SCSI 硬盘则标识为sdx~，SCSI 硬盘是用sd来表示分区所在设备的类型的，其余则和 IDE 硬盘的表示方法一样。 使用lsblk 命令查看当前系统的分区和挂载情况 List block 显示分区 输入lsblk -f 即可查看到当前系统的分区情况和相对应的挂载目录 显示的内容为： 分区情况、分区类型、UUID（universal unique id）唯一标识分区的40位不重复的字符串、挂载点 如果想看大小，可以直接输入lsblk查看 11.3、新增硬盘并挂载的详细步骤案例：给 Linux 系统增加一个新的硬盘，并且挂载到 /home/newdisk 虚拟机添加硬盘 12虚拟机 -&gt; 设置 -&gt; 硬件 -&gt; 添加 -&gt; 选择硬盘，下一步 -&gt; SCSI虚拟磁盘类型 -&gt; 分配空间 -&gt; 完成系统重启，再使用 lsblk -f 查看硬盘分区情况，可以查看到一个没有分区的硬盘sdb 分区 12345678fdisk /dev/sdb 进入分区引导m 寻求帮助n 添加一个新的分区p 设置为主分区 e是扩展分区选择主分区编号回车 + 回车，两次回车默认剩余全部空间w 分区信息写入硬盘并退出再使用 lsblk -f 查看分区情况可以发现只有分区sdb1但是没有对应的信息，这就是因为还没有格式化 格式化（MakeFileSystem）– 创建文件系统 12msfs -t ext4 /dev/sdb1 意思就是：把 sdb1 格式化成 ext4 这种分区类型 挂载，将一个分区和一个目录联系起来 1234567先创建一个目录 /home/newdiskmount /dev/sdb1 /home/newdisk -&gt; 挂载但是这样的设置挂载，当你重启机器的时候，硬盘和目录的挂载关系就会没有了，这个只是临时挂载如果想不挂载了，就使用umount 设备名称 或者 挂载目录例如： umount /dev/sdb1 或 者 umount /newdisk要想设置永久，就需要设置一个文件 设置可以自动挂载（永久挂载），当你重启系统，仍然可以挂载到 /home/newdisk 1234567891011编辑一个文件 vim /etc/fstab 这个文件就记录着分区和挂载点的情况-----------------------------------------------------------------------编辑其中的内容添加一行映射关系代码/dev/sdb1 /home/newdisk ext4 default 0 0保存退出-----------------------------------------------------------------------编辑完成后mount -a -a 就是自动挂载重启过后就能发现是永久挂载了 11.4、查看磁盘情况123456789101112131415161718192021df [选项] -&gt; 查询系统整体磁盘使用情况-l 列表显示du [选项] [目录] -&gt; 查询指定目录的磁盘占用情况，默认为当前目录-s 指定目录占用大小汇总-h 带计量单位-a 含文件--max-depth=1 子目录深度-c 列出明细的同时，增加汇总值例1 -&gt; 查询 /opt 目录的磁盘占用情况，深度为 1 -&gt; du -ach --max-depth=1 /opt例2 -&gt; 统计/home 文件夹下文件的个数 -&gt; ls -l /home | grep &quot;^-&quot; | wc -l例3 -&gt; 统计/home 文件夹下目录的个数 -&gt; ls -l /home | grep &quot;^d&quot; | wc -l例4 -&gt; 统计/home 文件夹下文件的个数，包括子文件夹里的 -&gt; ls -lR /home | grep &quot;^-&quot; | wc -l例5 -&gt; 统计文件夹下目录的个数，包括子文件夹里的 -&gt; ls -lR /home | grep &quot;^d&quot; | wc -l例6 -&gt; 以树状显示目录结构 -&gt; 先yum install tree，再tree解析：用了管道符分隔，先列出来，再过滤，再统计&quot;^-&quot;中 ^ 是定位符，表示开头 -表示以-开头的ls参数是区分大小写的 -&gt; 大写的R代表递归，小写的r（reverse）代表逆序 12、网络配置12.1、常用指令1234Windows下查看ip地址 -&gt; ipconfigLinux下查看ip地址 -&gt; ifconfig测试两个主机之间网路是否联通 -&gt; ping ip地址 12.2、Linux网络环境配置 可以通过图形化界面进行设置，设置自动连接 linux 启动后会自动获取 IP，缺点是每次自动获取的 ip 地址可能不一样 这个不适用于做服务器，因为我们的服务器的 ip 需要是固定的 通过修改配置文件指定固定ip 12345678910111213141516171819直接修改配置文件来指定IP，并可以连接到外网 -&gt; /etc/sysconfig/network-scripts/ifcfg-eth0第一个显卡就是eth0，第二个就是eth1例：要将 ip 地址配置成静态的，ip 地址为 192.168.184.130vim /etc/sysconfig/network-scripts/ifcfg-eth0 -&gt; 打开配置文件Linux会显示文件内容，其中要修改的内容如下 ↓↓↓↓DEVICE=eth0 -&gt;接口名（设备，网卡）HWADDR=00:0c:2x:6x:0x:xx -&gt; MAC地址TYPE=Ethernet -&gt; 网络类型UUID=926a57ba-92c6-4231-bacb-f27e5e6a9f44 -&gt; 随机IDONBOOT=yes -&gt; 系统启动的时候网络接口是否有效 静态，ONBOOT为yes；自动，ONBOOT为noBOOTPROTO=static -&gt; 以静态方式获得ip，还有bootp采用BOOTP协议 dhcp采用DHCP协议 none不使用协议IPADDR=192.168.184.130 -&gt; 指定ipGATEWAY=192.168.184.2 -&gt; 网关DNS1=192.168.184.2 -&gt; dns和网关保持一致即可修改后，一定要 重启服务service network restart或者直接 reboot 重启系统 13、进程管理13.1、进程的基本介绍 在 LINUX 中，每个执行的程序（代码）都称为一个进程。每一个进程都分配一个 ID 号 每一个进程，都会对应一个父进程，而这个父进程可以复制多个子进程。例如 www 服务器 每个进程都可能以两种方式存在的，前台与后台。所谓前台进程就是用户目前的屏幕上可以进行操作的。后台进程则是实际在操作（也称为守护进程），但由于屏幕上无法看到的进程，通常使用后台方式执行 一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中。直到关机才才结束 13.2、显示系统执行的进程12345678910111213141516171819202122232425262728293031323334353637383940414243查看进行使用的指令是 ps ,一般来说使用的参数是 ps -aux-a 显示当前终端所有的进程信息-u 以用户的格式显示进程信息-x 显示后台进程运行的参数-e 显示所有进程-f 全格式PID 进程识别号TTY 终端机号TIME 此进程所消CPU时间CMD 正在执行的命令或进程名例1：输入指令 ps -aux | moreUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND详解System V 展示风格USER：用户名称PID：进程号%CPU：进程占用 CPU 的百分比%MEM：进程占用物理内存的百分比VSZ：进程占用的虚拟内存大小（单位：KB）RSS：进程占用的物理内存大小（单位：KB）TTY：终端名称STAT：进程状态，其中 S-睡眠，s-表示该进程是会话的先导进程，N-表示进程拥有比普通优先级更低的优先级，R-正在运行，D-短期等待，Z-僵死进程，T-被跟踪或者被停止等等STARTED：进程的启动时间TIME：CPU 时间，即进程使用 CPU 的总时间COMMAND：启动进程所用的命令和参数，如果过长会被截断显示例2：输入指令 ps -ef | moreUID PID PPID C STIME TTY TIME CMD详解：UID：用户 IDPID：进程 IDPPID：父进程 IDC：CPU 用于计算执行优先级的因子。数值越大，表明进程是 CPU 密集型运算，执行优先级会降低；数值越小，表明进程是 I/O 密集型运算，执行优先级会提高STIME：进程启动的时间TTY：完整的终端名称TIME：CPU 时间CMD：启动进程所用的命令和参数 13.3、终止进程 kill 和 killall 若是某个进程执行一半需要停止时，或是已消了很大的系统资源时，此时可以考虑停止该进程 可使用 kill 命令来完成此项任务 123456789kill [选项] 进程号 -&gt; 通过进程号杀死进程-9 表示强迫进程立即停止killall 进程名称 -&gt; 通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用例子：踢掉某个用户 -&gt; ps -aux | grep sshd -&gt; 查看进程号 -&gt; kill 4010终止多个 gedit 编辑器 -&gt; killall gedit强制杀掉一个终端 -&gt; kill -9 4090 13.4、查看进程树123456pstree [选项] -p :显示进程的 PID-u :显示进程的所属用户例子：请你树状的形式显示进程的 pidpstree -p 13.5、服务管理 服务(service) 本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其它程序的请求，比如（mysql , sshd 防火墙等），因此我们又称为守护进程，是 Linux 中非常重要的知识点。 123456service 服务名 [start | stop | restart | reload | status]CentOS7.0 后 不再使用 service ,而是 systemctl查看服务名：1.使用setup-&gt;系统服务查看 CentOS7是nmtui 使用tab切换到[确定]和[取消]2.查看目录 ls -l /etc/init.d/ CentOS7使用 systemctl list-unit-files 可以列出所有的服务 13.6、查看防火墙1234567891011查看当前防火墙的状况 -&gt; service iptables status CentOS7改为 systemctl status firewalld关闭防火墙 -&gt; service iptables stop CentOS7改为 systemctl stop firewalld开启防火墙 -&gt; service iptables start CentOS7改为 systemctl start firewalld检查Linux的某个端口是否在监听并且可以访问 -&gt; telnet ip 端口号 例如 telnet 192.168.1.30 22yum list telnet* yum install telnet-server yum install telnet.* 按照这三条指令先安装亲测有效注意！1. 关闭或者启用防火墙后，立即生效2. 这种方式只是临时生效，当重启系统后，还是回归以前对服务的设置3. 如果希望设置某个服务自启动或关闭永久生效，要使用 chkconfig 指令 13.7、chkconfig 指令 通过chkconfig 命令可以给每个服务的各个运行级别设置自启动/关闭 但是这个指令只能在CentOS中使用 1234567891011chkconfig --list|grep xxx -&gt; 查看服务 chkconfig 服务名 --list -&gt; 查看服务 chkconfig --level 5 服务名 on/off -&gt; 修改服务在某个运行级别下的自启动例子：案例 1： 请显示当前系统所有服务的各个运行级别的运行状态 -&gt; chkconfig --list案例 2：请查看 sshd 服务的运行状态 -&gt; service sshd status案例 3： 将 sshd 服务在运行级别 5 下设置为不自动启动，看看有什么效果？ -&gt; chkconfig --level 5 sshd off案例 4： 当运行级别为 5 时，关闭防火墙 -&gt; chkconfig --level 5 iptables off案例 5： 在所有运行级别下，关闭防火墙 -&gt; chkconfig iptables off案例 6： 在所有运行级别下，开启防火墙 -&gt; chkconfig iptables on3 chkconfig 重新设置服务后自启动或关闭，==需要重启机器 reboot 才能生效== 13.8、动态监控进程 top 与 ps 命令很相似，它们都用来显示正在执行的进程 Top 与 ps 最大的不同之处，在于 top 在执行一段时间可以更新正在运行的的进程 有点类似于Windows下的任务管理器 123456789101112top [选项]选项说明：-d 秒数 -&gt; 指定top命令每隔几秒更新，默认是3秒在top命令的交互模式当中可以执行的命令-i -&gt; 使top不显示任何进闲置或僵死进程-p -&gt; 通过指定监控进程ID来仅仅监控某个进程的状态交互操作说明P -&gt; 以CPU使用率排序M -&gt; 以内存使用率排序N -&gt; 以PID排序q -&gt; 退出top输入u后输入某个用户名 -&gt; 查看该用户名的服务输入k，回车，再输入一个进程ID号 -&gt; 终止指定的进程 13.9、查看系统网路情况 netstat123456net [选项]-an -&gt; 按一定顺序排列输出-p -&gt; 显示哪个进程在调用案例1:查看系统所有的网络服务 -&gt; netstat -anp | more案例2:查看系统某一个网络服务 -&gt; netstat -anp | grep sshd 14、RPM14.1、基本介绍RPM是一种用于互联网下载包的打包及安装工具，它包含在某些 Linux 分发版中，生成具有.RPM 扩展名的文件 RPM 是 RedHat Package Manager（RedHat 软件包管理工具）的缩写，类似 windows 的 setup.exe，这一文件格式名称虽然打上了 RedHat 的标志，但理念是通用的 Linux 的分发版本都有采用（suse,redhat, centos 等等），可以算是公认的行业标准了。 14.2、查询RPM包123456789101112131415rpm -qa -&gt; 查询所安装的所有rpm 软件包rpm -qa | more -&gt; 分页显示rpm -qa | grep X [rpm -qa | grep firefox] -&gt; 指定查找某个软件rpm -qi 软件包名 -&gt; 查询软件包信息rpm -ql 软件包名 -&gt; 查询软件包中的文件rpm -qf 文件全路径名 -&gt; 查询文件所属的软件包基本格式：一个 rpm 包名：firefox-45.0.1-1.el6.centos.x86_64.rpm 名称:firefox版本号：45.0.1-1适用操作系统: el6.centos.x86_64表示 centos6.x 的 64 位系统如果是 i686、i386 表示 32 位系统，noarch 表示通用 14.3、安装RPM包12345rpm -ivh RPM包的全路径名称i=install 安装v=verbose 提示h=hash 进度条 14.4、卸载RPM包123456789rpm -e RPM包名注意事项：1. 如果其它软件包依赖于您要卸载的软件包，卸载时则会产生错误信息。如：$ rpm -e fooremoving these packages would break dependencies:foo is needed by bar-1.0-12. 如果我们就是要删除 foo 这个 rpm 包，可以增加参数 --nodeps ，就可以强制删除，但是一般不推荐这样做，因为依赖于该软件包的程序可能无法运行如：$ rpm -e --nodeps foo带上 --nodeps 就是强制删除。 15、YUM15.1、基本介绍 Yum 是一个 Shell 前端软件包管理器 YUM 基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包。使用 yum 的前提是已经联网。 123基本指令：查询 yum 服务器是否有需要安装的软件 -&gt; yum list|grep xx 软件列表下载安装指定的 yum 包 -&gt; yum install xxx 15.2、安装YUM包12345先查询软件列表 -&gt; yum list|grep jdk安装包 yum install java-1.8.0-openjdk.i686一般会默认安装最新的，你也可以指定安装某个包安装完成过后会删除安装包 如果需要卸载，直接通过RPM包管理卸载即可 16、JAVAEE环境安装16.1、需要安装jdk 这里安装 Java8 版本，而且是通过官网下载的压缩包进行解压，再配置 12345678先将软件通过 xftp5 上传到 /opt 下解压缩到 /opt -&gt; tar -zxvf jdk-8u181-linux-x64.tar.gz配置环境变量的配置文件 vim /etc/profile JAVA_HOME=/opt/jdk1.7.0_79 -&gt; JavaHome PATH=/opt/jdk1.7.0_79/bin:$PATH -&gt; 路径 export JAVA_HOME PATH -&gt; 输出变量，环境变量生效需要注销用户，环境变量才能生效 -&gt; 运行级别3就logout，运行级别5就重启输入 java -version 和 javac -version 查看是否配置成功 16.2、需要安装tomcat 一般spring boot项目会自带tomcat，就不需要安装，传统的SSM和SSH就需要tomcat服务器 12345678910上传文件过后解压缩到/opt启 动 tomcat ./startup.sh 进入bin目录 -&gt; cd apache-tomcat-7.0.70/bin/ ls 查看目录内文件 执行脚本文件 -&gt; ./startup.sh开放端口 8080 这样外网才能访问到 tomcat vim /etc/sysconfig/iptables 将开放22号端口的哪一行代码复制粘贴，将22改成8080即可开放8080端口 Centos7 -&gt; firewall-cmd --permanent --add-port=8080/tcp -&gt; firewall-cmd --reload centos8 -&gt; firewall-cmd --add-port=8080/tcp --permanent CentOS7 安装tomcat9可以查看教程 ：https://blog.csdn.net/mmmbox/article/details/89461518 16.3、需要安装数据库，这里安装MySQL 可查看教程：https://www.cnblogs.com/nicknailo/articles/8563737.html 初始密码的要求参数：https://www.cnblogs.com/newbest/p/9753706.html 16.4、如果是图形界面，还需要安装一款ide 这个可以直接在图形界面的软件商店中安装 17、Shell编程17.1、为什么要学Shell编程 Linux 运维工程师在进行服务器集群管理时，需要编写 Shell 程序来进行服务器管理。 对于 JavaEE 和 Python 程序员来说，工作的需要，你的老大会要求你编写一些Shell 脚本进行程序或者是服务器的维护，比如编写一个定时备份数据库的脚本。 对于大数据程序员来说，需要编写 Shell 程序来管理集群。 17.2、Shell是什么 Shell 是一个命令行解释器，它为用户提供了一个向Linux 内核发送请求以便运行程序的界面系统级程序，用户可以用 Shell 来启动、挂起、停止甚至是编写一些程序 在我们使用的过程中，应用程序调用shell或者我们直接执行shell脚本，然后shell操作Linux内核，内核再驱动硬件 shell主要是对我们的指令进行解析，解析指令给Linux内核。反馈结果在通过内核运行出结果，通过shell解析给用户 ==shell是外壳程序的统称，bash 是具体的一种shell== Shell编程开发原理 17.3、Shell脚本执行方式 格式要求： 脚本以#!/bin/bash 开头 脚本需要有可执行权限 快速写一个 输出 helloworld 的脚本 hello.sh 12#!/bin/bash -&gt; 表示shell脚本用bash来解析echo &quot;hello world&quot; 常用执行方式： 输入脚本的绝对路径或相对路径，即可执行 123chmod 744 hello.sh -&gt; 给所有者一个执行权限./hello.sh -&gt; 相对路径/root/shell/hello.sh -&gt; 绝对路径 输入指令：sh 脚本路径 这样可以不用赋予脚本执行权限，直接执行，但是==不推荐== 12sh ./hello.sh -&gt; 通过相对路径sh /root/shell/hello/sh -&gt; 通过绝对路径 17.4、Shell的变量17.4.1、Shell变量的介绍 Linux Shell 中的变量分为，==系统变量==和==用户自定义变量==。 12系统变量：$HOME、$PWD、$SHELL、$USER 等 比如： echo &quot;path=$PATH&quot;显示当前 shell 中所有变量：set 17.4.2、Shell变量的定义12345678910定义变量：变量=值撤销变量：unset 变量声明静态变量：readonly 变量， 注意：不能unset!把变量提升为全局环境变量，可供其他 shell 程序使用 --&gt; 详情见下一节 设置环境变量例：A=100readonly B=99echo &quot;A=$A&quot;unset A 17.4.3、定义变量的规则 变量名称可以由字母、数字和下划线组成，但是不能以数字开头。 等号两侧不能有空格 变量名称一般习惯为大写 17.4.4、将命令的返回值赋给变量（重点）12A=`ls -la` 用反引号将命令括起来 -&gt; 运行里面的命令并把结果返回给变量 AA=$(ls -la) 等价于反引号 17.5、设置环境变量17.5.1、基本语法123export 变量名=变量值 -&gt; 将 shell 变量输出为环境变量source 配置文件 -&gt; 让修改后的配置信息立即生效echo $变量名 -&gt; 查询环境变量的值 例如，在 /etc/profile 中设置一个环境变量$TOMCAT_HOME ，在我们自己写得shell脚本中引用，但是在配置过后，为了让 /etc/profile 中的环境变量生效，需要使用 source /etc/profile 或者重启系统/注销用户才能生效，类似于一个全局变量 17.5.2、快速入门12345678910# vim /etc/profile # 定义一个环境变量 TOMCAT_HOME='helloworld'export TOMCAT_HOME# 要使用 source /etc/profile 指令重新加载，不然使用不了# vim ./hello.sh#!/bin/bashecho &quot;$TOMCAT_HOME&quot; 17.6、位置参数变量17.6.1、介绍当我们执行一个 shell 脚本时，如果希望获取到命令行的参数信息，就可以使用到位置参数变量 比如 ： ./myshell.sh 100 200 , 这个就是一个执行 shell 的命令行，可以在 myshell 脚本中获取到参数信息 17.6.2、基本语法1234567$n -&gt; n 为数字，$0 代表命令本身，$1-$9 代表第一到第九个参数，十以上的参数，十以上的参数需要用大括号包含，如${10}$* -&gt; 这个变量代表命令行中所有的参数，$*把所有的参数看成一个整体$@ -&gt; 这个变量也代表命令行中所有的参数，不过$@把每个参数区分对待===&gt; 这两者的区别可以到循环语句的for循环语句存中查看区别$# -&gt; 这个变量代表命令行中所有参数的个数 17.6.3 应用实例 编写一个 shell 脚本 positionPara.sh ， 在脚本中获取到命令行的各个参数信息 123456789101112#!/bin/bash#获取各个参数echo $0 $1 $2echo $*echo $@echo &quot;参数个数=$#&quot;输入 ./positionPara.sh 100 200 300 后的输出效果./positionPara.sh 100 200100 200 300100 200 300 参数个数=3 17.7、预定义变量 基本介绍 预定义变量就是 shell 设计者事先已经定义好的变量，可以直接在 shell 脚本中使用 基本语法 123$$ -&gt; 当前进程的进程号（PID）$! -&gt; 后台运行的最后一个进程的进程号（PID）$？ -&gt; 最后一次执行的命令的返回状态。如果这个变量的值为 0，证明上一个命令正确执行；如果这个变量的值为非 0（具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确了。 应用实例 12345678910111213编写脚本 test.sh#!/bin/bashecho &quot;当前的进程号=$$&quot;# 后台的方式运行 ./myshell.sh 这个脚本./myshell.sh &amp;echo &quot;最后的进程号=$!&quot;echo &quot;最后一次执行的命令的返回状态：$?&quot;输出效果：当前的进程号=22083最后的进程号=22084最后一次执行的命令的返回状态：0 17.8、运算符 基本介绍 可以在 shell 中进行各种运算操作 基本语法 1234&quot;$((运算式))&quot;或&quot;$[运算式]&quot; -&gt; 推荐使用 $[运算式]expr m + n -&gt; 注意 expr 运算符间要有空格expr m - nexpr \\*, /, % -&gt; 乘，除，取余 应用案例 123456789计算（2+3）X4 的值 $((运算式)) -&gt; RESULT1=$(((2+3)*4)) $[运算式] -&gt; RESULT2=$[(2+3)*4] expr -&gt; TEMP=`expr 2 + 3` RESULT3=`expr $TEMP \\* 4`请求出命令行的两个参数[整数]的和 SUM=$[$1+$2] echo &quot;SUM=$SUM&quot; 输入指令 ./shelltest.sh 100 200 即可看到输出结果为 SUM=300 17.9、条件判断 基本语法 123456[ condition ] （注意 condition 前后要有空格）#非空返回 true，可使用$?验证（0 为 true，&gt;1 为 false）一些案例：[ string ] -&gt; 返回true[ ] -&gt; 返回false[ condition ] &amp;&amp; echo OK || echo notok -&gt; 类似于问号表达式，条件为真走前，假走后 常用判断条件 123456789101112131415161. 两个整数比较 = 字符串比较 -lt 小 于 -le 小于等于 -eq 等 于 -gt 大 于 -ge 大于等于 -ne 不等于2. 按照文件权限进行判断 -r 有读的权限 [ -r 文件 ] -w 有写的权限 -x 有执行的权限3. 按照文件类型进行判断 -f 文件存在并且是一个常规的文件 -e 文件存在 -d 文件存在并是一个目录 应用实例 123案例1：&quot;ok&quot;是否等于&quot;ok&quot; -&gt; [ &quot;ok&quot; = &quot;ok&quot; ] &amp;&amp; echo equal || echo notEqual案例2：23 是否大于等于 22 -&gt; [ 23 -gt 22 ] &amp;&amp; echo yes || echo no案例3：/root/install.log 目录中的文件是否存在 -&gt; [ -e /root/install.log ] &amp;&amp; echo have || echo nothave 17.10、循环和分支 if 判断 12345678910111213141516171819202122232425262728if [ 条件判断式 ];then 程序fi或者if [ 条件判断式 ]then 程序elif [条件判断式]then 程序fi注意事项：1. [ 条件判断式 ] 中括号和条件判断式之间必须有空格 2. 推荐使用第二种方式案例：请编写一个 shell 程序，如果输入的参数，大于等于 60，则输出 &quot;及格了&quot;，如果小于 60,则输出 &quot;不及格&quot;if [ $1 -ge 60 ]then echo &quot;及格了&quot;elif [ $1 -lt 60 ]then echo &quot;不及格&quot;fi输出结果：[root@iZwz98zprwjrt7d2pp9g0zZ shell]# ./test2.sh 60及格了[root@iZwz98zprwjrt7d2pp9g0zZ shell]# ./test2.sh 59不及格 case 语句 12345678910111213141516171819202122232425262728293031case $变量名 in&quot;值 1&quot;） 如果变量的值等于值 1，则执行程序 1;;&quot;值 2&quot;） 如果变量的值等于值 2，则执行程序 2;;…省略其他分支…*） 如果变量的值都不是以上的值，则执行此程序;;esac案例1：当命令行参数是 1 时，输出 &quot;周一&quot;, 是 2 时，就输出&quot;周二&quot;， 其它情况输出 &quot;other&quot;case $1 in&quot;1&quot;) echo &quot;周一&quot;;;&quot;2&quot;) echo &quot;周二&quot;;;*) echo &quot;other&quot;esac输出结果：[root@iZwz98zprwjrt7d2pp9g0zZ shell]# ./case.sh 1周一[root@iZwz98zprwjrt7d2pp9g0zZ shell]# ./case.sh 2周二[root@iZwz98zprwjrt7d2pp9g0zZ shell]# ./case.sh 3other for 循环 12345678910111213141516171819202122232425262728293031323334353637383940414243第一种方式：for 变量 in 值1 值2 值3…do 程序done第二种方式：for (( 初始值;循环控制条件;变量变化 ))do 程序done案例1：打印命令行输入的参数 -&gt; 顺便讲解一下 $* 和 $@ 的区别 代码： #!/bin/bash for i in &quot;$*&quot; do echo &quot;the num is $i&quot; done echo &quot;==============&quot; for j in &quot;$@&quot; do echo &quot;the num is $j&quot; done 输出效果： [root@iZwz98zprwjrt7d2pp9g0zZ shell]# ./for.sh 1 2 3 4 5 6 the num is 1 2 3 4 5 6 ============== the num is 1 the num is 2 the num is 3 the num is 4 the num is 5 the num is 6案例2：从 1 加到 100 的值输出显示 代码： SUM=0 for ((i=1;i&lt;=100;i++)) do SUM=$[SUM+$i] done echo &quot;SUM=$SUM&quot; 输出效果： SUM=5050 while 循环 123456789101112131415161718while [ 条件判断式 ] -&gt; 注意空格，while后面是有空格的do 程序done案例1：从命令行输入一个数 n，统计从 1+..+ n 的值 代码： SUM=0 i=0 while [ $i -le $1 ] do SUM=$[$SUM+$i] i=$[$i+1] done echo &quot;sum=$SUM&quot; 输入指令： ./while.sh 100 输出效果： sum=5050 17.11、read 读取控制台输入基本语法 1234567891011read [选项] [参数] 赋值变量名-p：指定读取值时的提示符，然后会阻塞等你输入一个值，回车后继续执行-t：指定读取值时等待的时间（秒），如果没有在指定的时间内输入，就不再等待了赋值变量名：会将读取到的值赋给该变量例1：读取控制台输入一个 num 值read -p &quot;请输入一个num值：&quot; NUM1echo &quot;num=$NUM1&quot;例2：读取控制台输入一个 num 值，在 10 秒内输入read -t 3 -p &quot;请输入一个num值：&quot; NUM2echo &quot;num2=$NUM2&quot; 17.12、函数 函数介绍 shell 编程和其它编程语言一样，有系统函数，也可以自定义函数。系统函数中，我们这里就介绍两个：basename和dirname 系统函数 basename =&gt; 返回完整路径最后 / 的部分，常用于获取文件名 1234567basename [pathname] [suffix] basename命令会删掉所有的前缀包括最后一个（‘/’）字符，然后将字符串显示出来 suffix 为后缀，如果 suffix 被指定了，basename 会将 pathname 或 string 中的 suffix 去掉例子：请返回 /root/shell/read.sh 的 &quot;read.sh&quot; 部分 basename /root/shell/read.sh -&gt; 返回 read.sh basename /root/shell/read.sh .sh -&gt; 如果加上后缀则只返回文件名 read dirname =&gt; 返回完整路径最后 / 的前面的部分，常用于返回路径部分 12345dirname 文件绝对路径 从给定的包含绝对路径的文件名中去除文件名（非目录的部分），然后返回剩下的路径（目录的部分）例子：请返回 /root/shell/read.sh 的 /root/shelldirname /root/shell/read.sh -&gt; 返回前面的路径 /root/shell 自定义函数 12345678910111213141516171819202122232425function funname(){ Action; [return int;]}调用直接写函数名： funname [值]例子：计算输入两个参数的和（read）， getSum 代码： #!/bin/bash function getSum(){ SUM=$[$n1+$n2] echo &quot;和是:$SUM&quot; } read -p &quot;请输入a:&quot; n1 read -p &quot;请输入b:&quot; n2 getSum $n1 $n2 输入指令： ./fun.sh 输出： [root@iZwz98zprwjrt7d2pp9g0zZ shell]# ./fun.sh 请输入a:1 请输入b:2 和是:3 17.13、Shell编程综合案例 需求分析： 每天凌晨 2:10 备份 数据库 testDB 到 /data/backup/db 备份开始和备份结束能够给出相应的提示信息 备份后的文件要求以备份时间为文件名，并打包成 .tar.gz 的形式，比如：2018-03-12_230201.tar.gz 在备份的同时，检查是否有 10 天前备份的数据库文件，如果有就将其删除。 思路分析： 数据库中有一个 testDB ，要在Linux的 /data/backup/db 下备份数据库 现在在 /usr/sbin 下写一个 mysql_db_bbackup.sh 脚本来实现这个功能 写完脚本后交给crond来做定时任务调度 代码实现： 12345678910111213141516171819202122232425262728293031323334353637383940vim /usr/sbin/mysql_db_bbackup.sh#!/bin/bash# 数据库的备份# 定义备份的路径BACKUP=/data/backup/db# 获取当前的时间，作为文件名DATETIME=$(data +%Y_%m_%d_%H%M%S)# 输出变量查看 以作调试echo $DATETIMEecho &quot;======开始备份======&quot;echo &quot;======备份的路径是 $BACKUP/$DATETIME.tar.gz======&quot;# 主机HOST=localhost# 用户名字DB_USER=root# 密码DB_PASSWD=root# 数据库名DATABASE=testDB# 创建备份的路径 如果备份的路径文件夹存在就使用，没有就创建[ ! -d &quot;$BACKUP/$DATETIME&quot; ] &amp;&amp; mkdir -p &quot;$BACKUP/$DATETIME&quot;# 执行mysql的备份数据库的指令 将备份完后的内容进行压缩，形成一个临时的压缩包文件mysqldump -u${DB_USER} -p${DB_PASSWD} --host=$HOST $DATABASE | gzip &gt; $BACKUP/$DATETIME/$DATETIME.sql.gz# 打包备份文件cd $BACKUPtar -zcvf $DATETIME.tar.gz $DATETIME# 删除临时目录rm -rf $BACKUP/$DATETIME# 删除10天前的备份文件find $BACKUP -mtime +10 -name &quot;*.tar.gz&quot; -exec rm -rf {} \\;echo &quot;======备份成功======&quot;至此shell脚本编写完成然后将脚本交给crond定时执行crontab -e10 2 * * * /usr/sbin/mysql_db_bbackup.sh","link":"/%E7%AC%94%E8%AE%B0/linux/Linux%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0.html"},{"title":"docker常用命令","text":"docker常用命令 12345678910111213141516171819202122232425262728293031323334353637attach Attach to a running container # 当前 shell 下 attach 连接指定运行镜像build Build an image from a Dockerfile # 通过 Dockerfile 定制镜像commit Create a new image from a container changes # 提交当前容器为新的镜像cp Copy files/folders from the containers filesystem to the host path #从容器中拷贝指定文件或者目录到宿主机中create Create a new container # 创建一个新的容器，同run，但不启动容器diff Inspect changes on a container's filesystem # 查看 docker 容器变化events Get real time events from the server # 从 docker 服务获取容器实时事件exec Run a command in an existing container # 在已存在的容器上运行命令export Stream the contents of a container as a tar archive # 导出容器的内容流作为一个tar归档文件[对应import]history Show the history of an image # 展示一个镜像形成历史images List images #列出系统当前镜像import Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export]info Display system-wide information #显示系统相关信息inspect Return 1ow-level information on a container #查看容器详细信息(元数据)kill Kill a running container # kill 指定 docker 容器load Load an image from a tar archive # 从一个 tar 包中加载一个镜像[对应 save]login Register or Login to the docker registry server # 注册或者登陆一个 docker 源服务器logout Log out from a Docker registry server # 从当前 Docker registry 退出logs Fetch the logs of a container # 输出当前容器日志信息port Lookup the public-facing port which is NAT-ed to PRIVATE_PORT # 查看映射端口对应的容器内部源端pause Pause all processes within a container # 暂停容器ps List containers # 列出容器列表pull Pull an image or a repository from the docker registry server #从docker镜像源服务器拉取指定像或者库镜像push Push an image or a repository to the docker registry server # 推送指定镜像或者库镜像至docker服务器restart Restart a running container # 重启运行的容器rm Remove one or more containers # 移除一个或者多个容器rmi Remove one or more images # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]run Run a command in a new container # 创建一个新的容器并运行一个命令save Save an image to a tar archive # 保存一个镜像为一个 tar 包[对应 1oad]search Search for an image on the Docker Hub # 在 docker hub 中搜索镜像start Start a stopped containers # 启动容器stop Stop a running containers # 停止容器tag Tag an image into a repository # 给源中镜像打标签top Lookup the running processes of a container # 查看容器中运行的进程信息unpause Unpause a paused container # 取消暂停容器version Show the docker version information # 查看 docker 版本号wait Block until a container stops, then print its exit code # 截取容器停止时的退出状态值","link":"/%E7%AC%94%E8%AE%B0/docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html"}],"tags":[{"name":"Getting Started","slug":"Getting-Started","link":"/tags/Getting-Started/"},{"name":"Icarus User Guide","slug":"Icarus-User-Guide","link":"/tags/Icarus-User-Guide/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"redis","slug":"redis","link":"/tags/redis/"},{"name":"docker","slug":"docker","link":"/tags/docker/"}],"categories":[{"name":"Plugins","slug":"Plugins","link":"/categories/Plugins/"},{"name":"Comment","slug":"Plugins/Comment","link":"/categories/Plugins/Comment/"},{"name":"java","slug":"java","link":"/categories/java/"},{"name":"java基础","slug":"java/java基础","link":"/categories/java/java%E5%9F%BA%E7%A1%80/"},{"name":"笔记","slug":"笔记","link":"/categories/%E7%AC%94%E8%AE%B0/"},{"name":"redis","slug":"笔记/redis","link":"/categories/%E7%AC%94%E8%AE%B0/redis/"},{"name":"linux","slug":"笔记/linux","link":"/categories/%E7%AC%94%E8%AE%B0/linux/"},{"name":"docker","slug":"笔记/docker","link":"/categories/%E7%AC%94%E8%AE%B0/docker/"}]}